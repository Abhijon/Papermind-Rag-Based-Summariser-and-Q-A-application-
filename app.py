from flask import Flask, render_template, request, jsonify
from main import extractpdftext, generate_summary
from rag_qa import rag_qa
import os

app = Flask(__name__)

# Configure maximum upload size (20 MB) - reduced to prevent MemoryError
app.config['MAX_CONTENT_LENGTH'] = 20 * 1024 * 1024  # 20MB in bytes

@app.route('/', methods=['POST', 'GET'])
def main():
    return render_template("index.html")

@app.route('/summary',methods=['POST'])
def summary():
    try:
        data = request.form
        input_data = data.get('inputText')
        selectedOption = data.get('selectedOption')
        model = data.get('selectedModel')
        from_page = data.get('from')
        till_page = data.get('till')
        uploaded_files = request.files.getlist('file')
        if(selectedOption=='pdf'):
            if uploaded_files:
                combined_text = ""
                for uploaded_file in uploaded_files:
                    if uploaded_file.filename == '': continue
                    filepath = f'temp/{uploaded_file.filename}'
                    uploaded_file.save(filepath)
                    
                    print(f"File recived {input_data} , {uploaded_file.filename}, {uploaded_file}")
                    text = extractpdftext(filepath,int(from_page),int(till_page))
                    combined_text += text + "\n"
                    
                    # Delete the PDF file after extracting text to save storage
                    try:
                        os.remove(filepath)
                        print(f"Deleted PDF file: {uploaded_file.filename}")
                    except Exception as e:
                        print(f"Warning: Could not delete {filepath}: {e}")
                
                with open('temp/pdftext.txt', 'w', encoding='utf-8') as f:
                    f.write(combined_text)

                summary = generate_summary(selectedOption, input_data , model)
                
                # Automatically create vector store for Q&A
                try:
                    num_chunks = rag_qa.create_vector_store(combined_text)
                    rag_qa.save_vector_store()
                    print(f"Vector store created with {num_chunks} chunks")
                except Exception as e:
                    print(f"Warning: Could not create vector store: {e}")
                
                return jsonify({'result': summary})
            else:
                return jsonify({'result': "File Not found or file invalid"})
        #result = f"You submitted: {input_data} and {selectedOption}"
        #yield "answer is coming"
        summary = generate_summary(selectedOption, input_data , model)

        # Create vector store for YouTube and Text
        try:
            full_text = ""
            if selectedOption == 'youtube':
                # Read the subtitles file generated by generate_summary
                if os.path.exists('temp/subtitles.txt'):
                    with open('temp/subtitles.txt', 'r', encoding='utf-8') as f:
                        full_text = f.read()
            else:
                # For direct text input
                full_text = input_data

            if full_text and len(full_text.strip()) > 0:
                num_chunks = rag_qa.create_vector_store(full_text)
                rag_qa.save_vector_store()
                print(f"Vector store created for {selectedOption} with {num_chunks} chunks")
        except Exception as e:
            print(f"Warning: Could not create vector store for {selectedOption}: {e}")

        return jsonify({'result': summary})
    except Exception as e:
        return jsonify({'result': "error: "+str(e)})
    
    
@app.route('/create_vector_store', methods=['POST'])
def create_vector_store():
    """Create vector store from the uploaded PDF text"""
    try:
        # Check if PDF text exists
        pdf_text_path = 'temp/pdftext.txt'
        if not os.path.exists(pdf_text_path):
            return jsonify({
                'success': False,
                'message': 'No PDF text found. Please upload a PDF first.'
            })
        
        # Read the PDF text
        with open(pdf_text_path, 'r', encoding='utf-8') as f:
            text = f.read()
        
        if not text or len(text.strip()) < 50:
            return jsonify({
                'success': False,
                'message': 'PDF text is too short or empty.'
            })
        
        # Create vector store
        num_chunks = rag_qa.create_vector_store(text)
        
        # Save vector store
        rag_qa.save_vector_store()
        
        return jsonify({
            'success': True,
            'message': f'Vector store created successfully with {num_chunks} chunks. You can now ask questions!',
            'num_chunks': num_chunks
        })
    
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'Error creating vector store: {str(e)}'
        })

@app.route('/ask', methods=['POST'])
def ask_question():
    try:
        data = request.get_json()
        question = data.get('question', '').strip()
        
        if not question:
            return jsonify({'success': False, 'answer': 'Please provide a question.'})

        vector_store_path = "temp/vector_store"
        
        # Check if vector store exists on disk
        if not os.path.exists(vector_store_path):
            return jsonify({
                'success': False,
                'answer': 'No vector store found. Please upload a PDF and create the vector store first.'
            })
        
        if not (os.path.exists(os.path.join(vector_store_path, "index.faiss")) or 
                os.path.exists(os.path.join(vector_store_path, "index.pkl"))):
            return jsonify({
                'success': False,
                'answer': 'Vector store is corrupted or empty. Please re-upload the PDF.'
            })

        # Load if not already in memory
        if not rag_qa.qa_chain:
            success = rag_qa.load_vector_store(vector_store_path)
            if not success:
                return jsonify({
                    'success': False,
                    'answer': 'Failed to load vector store. Please try uploading again.'
                })

        result = rag_qa.ask_question(question)
        
        return jsonify({
            'success': True,
            'answer': result['answer'],
            'sources': result.get('source_documents', [])[:2]
        })

    except Exception as e:
        return jsonify({
            'success': False,
            'answer': f'Error processing question: {str(e)}'
        })

@app.route('/clear_vector_store', methods=['POST'])
def clear_vector_store():
    """Clear the vector store"""
    try:
        rag_qa.clear_vector_store()
        return jsonify({
            'success': True,
            'message': 'Vector store cleared successfully.'
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'Error clearing vector store: {str(e)}'
        })

def cleanup_old_temp_files(max_age_hours=24):
    """Delete temporary files older than max_age_hours"""
    import time
    import shutil
    
    temp_dir = 'temp'
    if not os.path.exists(temp_dir):
        return
    
    current_time = time.time()
    max_age_seconds = max_age_hours * 3600
    
    try:
        for filename in os.listdir(temp_dir):
            filepath = os.path.join(temp_dir, filename)
            
            # Skip if it's a directory (like vector_store)
            if os.path.isdir(filepath):
                # Remove old vector store directories
                file_age = current_time - os.path.getmtime(filepath)
                if file_age > max_age_seconds:
                    shutil.rmtree(filepath)
                    print(f"Deleted old directory: {filepath}")
            else:
                # Remove old files
                file_age = current_time - os.path.getmtime(filepath)
                if file_age > max_age_seconds:
                    os.remove(filepath)
                    print(f"Deleted old file: {filepath}")
    except Exception as e:
        print(f"Error during cleanup: {e}")

@app.errorhandler(413)
def request_entity_too_large(error):
    """Handle file size exceeding the maximum limit"""
    return jsonify({
        'result': 'Error: File size exceeds the maximum limit of 100MB. Please upload a smaller file.'
    }), 413


if __name__ == '__main__':
    # Clean up old temporary files on startup
    print("Cleaning up old temporary files...")
    cleanup_old_temp_files(max_age_hours=24)
    print("Cleanup complete. Starting Flask app...")
    
    app.run(host='127.0.0.1', port=5000, debug=True)
